
<html>
<head>
    <title>Poinky Test1</title>
    <script src="js/three.js"></script>
    <script src="js/stats.js"></script>
    <script src="js/physi.js"></script>
    <script src="fonts/helvetiker_bold.typeface.js"></script>
    <script src="fonts/helvetiker_regular.typeface.js"></script>
    <script src="js/MarchingCubes.js"></script>
    <script type="x-shader/x-vertex" id="vertexShader">

        varying vec3 vNormal;
        varying vec4 vPosition;
        varying vec4 vOPosition;
        varying vec3 vONormal;
        varying vec3 vU;
        varying vec3 vEye;

        void main() {

        vOPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * vOPosition;

        vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );

        vPosition = vec4( position, 1.0 );
        vNormal = normalMatrix * normal;
        vONormal = normal;

        }

    </script>
    <script type="x-shader/x-vertex" id="fragmentShader">

        uniform sampler2D textureMap;
        uniform sampler2D normalMap;
        uniform vec3 color;
        uniform float normalScale;
        uniform float texScale;
        uniform float useSSS;
        uniform float useScreen;

        varying vec3 vNormal;
        varying vec4 vPosition;
        varying vec4 vOPosition;
        varying vec3 vONormal;
        varying vec3 vU;
        varying vec3 vEye;

        float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}

        void main() {

        vec3 n = normalize( vONormal.xyz );
        vec3 blend_weights = abs( n );
        blend_weights = ( blend_weights - 0.2 ) * 7.;
        blend_weights = max( blend_weights, 0. );
        blend_weights /= ( blend_weights.x + blend_weights.y + blend_weights.z );

        vec2 coord1 = vPosition.yz * texScale;
        vec2 coord2 = vPosition.zx * texScale;
        vec2 coord3 = vPosition.xy * texScale;

        vec3 bump1 = texture2D( normalMap, coord1 ).rgb;
        vec3 bump2 = texture2D( normalMap, coord2 ).rgb;
        vec3 bump3 = texture2D( normalMap, coord3 ).rgb;

        vec3 blended_bump = bump1 * blend_weights.xxx +
        bump2 * blend_weights.yyy +
        bump3 * blend_weights.zzz;

        vec3 tanX = vec3( vNormal.x, -vNormal.z, vNormal.y);
        vec3 tanY = vec3( vNormal.z, vNormal.y, -vNormal.x);
        vec3 tanZ = vec3(-vNormal.y, vNormal.x, vNormal.z);
        vec3 blended_tangent = tanX * blend_weights.xxx +
        tanY * blend_weights.yyy +
        tanZ * blend_weights.zzz;

        vec3 normalTex = blended_bump * 2.0 - 1.0;
        normalTex.xy *= normalScale;
        normalTex.y *= -1.;
        normalTex = normalize( normalTex );
        mat3 tsb = mat3( normalize( blended_tangent ), normalize( cross( vNormal, blended_tangent ) ), normalize( vNormal ) );
        vec3 finalNormal = tsb * normalTex;

        vec3 r = reflect( normalize( vU ), normalize( finalNormal ) );
        float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z + 1.0 ) );
        vec2 calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 );

        vec3 base = texture2D( textureMap, calculatedNormal ).rgb;

        float rim = 1.75 * max( 0., abs( dot( normalize( vNormal ), normalize( -vOPosition.xyz ) ) ) );
        base += useSSS * color * ( 1. - .75 * rim );
        base += ( 1. - useSSS ) * 10. * base * color * clamp( 1. - rim, 0., .15 );

        if( useScreen == 1. ) {
        base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base );
        }

        float nn = .05 * random( vec3( 1. ), length( gl_FragCoord ) );
        base += vec3( nn );

        gl_FragColor = vec4( base.rgb, 1. );

        }

    </script>

    <script type="x-shader/x-vertex" id="sphere-vs">

        void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }

    </script>
    <script type="x-shader/x-vertex" id="sphere-fs">

        uniform vec2 resolution;
        uniform float noise;
        uniform vec3 color;

        #define VIG_REDUCTION_POWER 1.
        #define VIG_BOOST 1.

        float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}

        void main() {

        vec2 center = resolution * 0.5;
        float vignette = distance( center, gl_FragCoord.xy ) / resolution.x;
        vignette = VIG_BOOST - vignette * VIG_REDUCTION_POWER;

        float n = noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );

        float v = .5 * length( vec2( gl_FragCoord.y / resolution.y, ( 1. - abs( .5 - gl_FragCoord.x / resolution.x ) ) ) );
        vec3 base = color;
        base += vec3( pow( v, 2. ) );
        gl_FragColor = vec4( base * vec3( vignette ) + vec3( n ), 1. );

        }

    </script>


    <style>
        body, html {
            padding: 0;
            margin: 0;
        }
    </style>


</head>
<body>
    <script>
        Physijs.scripts.worker = 'js/physijs_worker.js';
        Physijs.scripts.ammo = 'ammo.js';

        var three = THREE;
        var effect;

        var scene = new Physijs.Scene();
        scene.setGravity(new THREE.Vector3(0, -98, 0));
        scene.addEventListener('update', update);
        var scene2 = new THREE.Scene();
        var renderer = new three.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
        renderer.shadowMapSoft = true;

        document.body.appendChild(renderer.domElement);

        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.set(0, 40, 40);
        camera.lookAt(scene.position);
        // Materials
        ground_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ color: 0xff0000 }),
			.8, // high friction
			.4 // low restitution
		);

        ball_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({
			    transparent: true,
			    color: 0xaaffaa,
			    refractionRatio: 0.97,
			    reflectivity: 0.8
			}),
			.4, // low friction
			.8 // high restitution
		);


        // Meshes
        var ground = new Physijs.BoxMesh(
			new THREE.BoxGeometry(100, 5, 300),
			ground_material,
			0 // mass
		);
        ground.position.y = -18;
        ground.receiveShadow = true;

        var ballBase = new Physijs.SphereMesh(
				new THREE.IcosahedronGeometry(5, 4),
				ball_material,
                1000
			);
        ballBase.position.set(-5, 10, 0);
        ballBase.castShadow = true;

        var ballMid = new Physijs.SphereMesh(
				new THREE.IcosahedronGeometry(5, 4),
				ball_material,
                1
			);
        ballMid.position.set(-5, 19.9, 0);
        ballMid.castShadow = true;

        // Light
        var light = new THREE.DirectionalLight(0xFFFFFF);
        light.position.set(20, 40, -15);
        light.target.position.copy(scene.position);
        light.castShadow = true;
        light.shadowCameraLeft = -60;
        light.shadowCameraTop = -60;
        light.shadowCameraRight = 60;
        light.shadowCameraBottom = 60;
        light.shadowCameraNear = 20;
        light.shadowCameraFar = 200;
        light.shadowBias = -.0001
        light.shadowMapWidth = light.shadowMapHeight = 2048;
        light.shadowDarkness = .7;

        var ambient = new three.AmbientLight(0x111111);
        ambient.intensity = 0.1;

        scene.add(camera);
        scene.add(light);
        scene.add(ambient);
        scene.add(ground);
        scene.add(ballBase);
        scene.add(ballMid);

        resolution = 30;
        //effect
        material = new THREE.ShaderMaterial({

            uniforms: {
                textureMap: { type: 't', value: null },
                normalMap: { type: 't', value: null },
                normalScale: { type: 'f', value: 1 },
                texScale: { type: 'f', value: 5 },
                useSSS: { type: 'f', value: 1 },
                useScreen: { type: 'f', value: 0 },
                color: { type: 'c', value: new THREE.Color(0, 0, 0) }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            side: THREE.FrontSide

        });
        material.uniforms.normalScale.value = .5;
        material.uniforms.texScale.value = 10;
        material.uniforms.useSSS.value = .15;
        material.uniforms.useScreen.value = 0;

        material.uniforms.color.value.setRGB(80. / 255., 72. / 255., 85. / 255.);

        material.uniforms.textureMap.value = THREE.ImageUtils.loadTexture('matcap2.jpg');
        material.uniforms.textureMap.value.wrapS = material.uniforms.textureMap.value.wrapT = THREE.ClampToEdgeWrapping;

        //remove to get the old effect
        material.uniforms.normalMap.value = THREE.ImageUtils.loadTexture('ice-snow.jpg');
        material.uniforms.normalMap.value.wrapS = material.uniforms.normalMap.value.wrapT = THREE.RepeatWrapping;
        //end remove to get the old effect

        resolution = 50;

        effect = new THREE.MarchingCubes(resolution, material, true, true);
        effect.position.set(0, 0, 0);
        effect.scale.set(20, 20, 20);
        effect.isolation = 60;

        scene2.add(effect);
        scene2.add(camera);
        scene2.add(light);
        scene2.add(ambient);


        //endeffect
        var baseMidConstraint = new Physijs.HingeConstraint(ballBase, ballMid, new THREE.Vector3(-5, 14.9, 0), new THREE.Vector3(0, 0, 1));
        scene.addConstraint(baseMidConstraint, true);
        var hazza = three.Math.degToRad(8);
        baseMidConstraint.setLimits(-hazza, hazza, null, 0.4);

        baseMidConstraint.enableAngularMotor(2, 0.5);
        setTimeout(function () {
            console.log(baseMidConstraint);
            baseMidConstraint.enableAngularMotor(0, 0);
        }, 5000);

        var render_stats = new Stats();
        render_stats.domElement.style.position = 'absolute';
        render_stats.domElement.style.top = '1px';
        render_stats.domElement.style.zIndex = 100;
        document.body.appendChild(render_stats.domElement);

        var physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        document.body.appendChild(physics_stats.domElement);

        requestAnimationFrame(render);
        scene.simulate();

        //sky sphere
        sphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                resolution: { type: 'v2', value: new THREE.Vector2(0, 0) },
                noise: { type: 'f', value: .04 },
                color: { type: 'c', value: new THREE.Color(0, 0, 0) }
            },
            vertexShader: document.getElementById('sphere-vs').textContent,
            fragmentShader: document.getElementById('sphere-fs').textContent,
            side: THREE.DoubleSide

        });
        sphereMaterial.uniforms.color.value.setRGB(18. / 255., 72. / 255., 85. / 255.);
        sphereMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        var horizon = new three.Mesh(new three.CubeGeometry(50, .5, 1000), material);
        horizon.position.y = -12;
        var sphere = new THREE.Mesh(new THREE.IcosahedronGeometry(3000, 1), sphereMaterial);
        scene2.add(sphere);
        var ground2 = ground.clone();
        scene2.add(ground2);
        scene2.add(horizon);
        ///

        function update() {
            //applyForce();

            ballBase.setAngularVelocity(new three.Vector3(0, 0, 0));

            scene.simulate(undefined, 1);
            physics_stats.update();
        };

        function render() {
            ground2.position = ground.position;
            ballBase.rotation.set(0, 0, 0);
            requestAnimationFrame(render);
            effect.reset();
            effect.position.z = ballBase.position.z;
            effect.position.x = ballBase.position.x;
            strength = 1.2 / ((Math.sqrt(2) - 1) / 4 + 1);
            effect.addPlaneY(3, 12);

            var ballPosition = new three.Vector3(ballBase.position.x, ballBase.position.y, ballBase.position.z);
            effect.worldToLocal(ballPosition);
            ballPosition.x = (ballPosition.x + 1) / 2;
            ballPosition.y = (ballPosition.y + 1) / 2;
            ballPosition.z = (ballPosition.z + 1) / 2;
            effect.addBall(ballPosition.x, ballPosition.y, ballPosition.z, 1.2, 12);
            ballPosition = new three.Vector3(ballMid.position.x, ballMid.position.y - 5, ballMid.position.z);
            effect.worldToLocal(ballPosition);
            ballPosition.x = (ballPosition.x + 1) / 2;
            ballPosition.y = (ballPosition.y + 1) / 2;
            ballPosition.z = (ballPosition.z + 1) / 2;
            effect.addBall(ballPosition.x, ballPosition.y, ballPosition.z, .8, 12);

            ballPosition = new three.Vector3(ballMid.position.x, ballMid.position.y, ballMid.position.z);
            effect.worldToLocal(ballPosition);
            ballPosition.x = (ballPosition.x + 1) / 2;
            ballPosition.y = (ballPosition.y + 1) / 2;
            ballPosition.z = (ballPosition.z + 1) / 2;
            effect.addBall(ballPosition.x, ballPosition.y, ballPosition.z, .4, 12);

            renderer.render(scene2, camera);

            render_stats.update();
        };

        var flipper = -10000; // :D
        function jump() {
            ballBase.applyImpulse(new three.Vector3(flipper = -flipper, 50000, -4000), new three.Vector3(0, 0, 0));
        }
        setTimeout(function () {
            setInterval(jump, 2000);
        }, 2000);

    </script>
</body>
</html>